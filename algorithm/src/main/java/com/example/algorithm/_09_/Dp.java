package com.example.algorithm._09_;

import java.util.Arrays;

public class Dp {

    public static void main(String[] args) {

        int value[] = {60, 100, 120};
        int weigth[] = {10, 20, 40};    //購物車那個問題 只需要一個價值就行了，重量都都沒有。

        int w = 50;
        int n = 3;
        int dp[][] = new int[n + 1][w + 1];        //n表示是物品，w表示重量,初始化全是0

        for (int i = 1; i <= n; i++) {    //每次加的物品 1~3
            for (int cw = 1; cw <= w; cw++) {        //分割的背包 1~51
                if (weigth[i - 1] <= cw) {        //表示這個物品可以裝進去
                    //這一格＝max( 加入的i物件value +  , 上一格)
                    dp[i][cw] = Math.max(value[i - 1] + dp[i - 1][cw - weigth[i - 1]], dp[i - 1][cw]);
                } else {
                    dp[i][cw] = dp[i - 1][cw];    //不能裝
                }
            }
        }
        /*
         * 因為陣列是從0開始算起，所以第一行跟第一列是無效空間．
         * [思考為什麼不用n-1去用？]
         * 因為在底層算法中，做減法運算其實相當耗效能，寧可站浪費空間也不要去浪費運算資源
         * 動態規劃在每一個array儲存值中，都已經將當下最優解（將當下運算對比於上一格運算相比取max存入）
         * 所以最憂解就在最後一行的最後一列
         */
        System.out.println(Arrays.deepToString(dp));

        /*
       陣列：每個新物件加入後，每公斤背包能夠裝載的價值

[
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 180]
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160],
]

         */
        System.out.println(dp[n][w]);

    }
}
